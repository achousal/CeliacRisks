"""
ROC and Precision-Recall curve plotting.

Provides functions to generate ROC and PR curves with confidence intervals
and threshold annotations.
"""

from collections.abc import Sequence
from pathlib import Path

import numpy as np
import pandas as pd

from .dca import apply_plot_metadata

try:
    import matplotlib

    matplotlib.use("Agg")
    import matplotlib.pyplot as plt
    from sklearn.metrics import (
        average_precision_score,
        precision_recall_curve,
        roc_auc_score,
        roc_curve,
    )

    _HAS_PLOTTING = True
except ImportError:
    _HAS_PLOTTING = False


def plot_roc_curve(
    y_true: np.ndarray,
    y_pred: np.ndarray,
    out_path: Path,
    title: str,
    subtitle: str = "",
    split_ids: np.ndarray | None = None,
    meta_lines: Sequence[str] | None = None,
    threshold_bundle: dict | None = None,
    skip_ci_band: bool = False,
) -> None:
    """
    Plot ROC curve with optional split-wise confidence bands and threshold markers.

    Args:
        y_true: True binary labels
        y_pred: Predicted probabilities
        out_path: Output file path
        title: Plot title
        subtitle: Optional subtitle
        split_ids: Array indicating split membership for each sample
        meta_lines: Optional metadata lines to display at bottom
        threshold_bundle: ThresholdBundle from compute_threshold_bundle() containing
            threshold values and metrics. See ced_ml.metrics.thresholds.compute_threshold_bundle().
        skip_ci_band: If True, skip rendering 95% CI band (only show ±1 SD).
            Useful for ensemble models where CI and SD are redundant.

    Returns:
        None. Saves plot to out_path.

    Example:
        >>> from ced_ml.metrics.thresholds import compute_threshold_bundle
        >>> bundle = compute_threshold_bundle(y_true, y_pred, target_spec=0.95)
        >>> plot_roc_curve(y_true, y_pred, "roc.png", "My Model", threshold_bundle=bundle)
    """
    # Extract threshold information from bundle if provided
    youden_threshold = None
    alpha_threshold = None
    metrics_at_thresholds = None

    if threshold_bundle is not None:
        youden_threshold = threshold_bundle.get("youden_threshold")
        alpha_threshold = threshold_bundle.get("spec_target_threshold")
        metrics_at_thresholds = {
            "youden": threshold_bundle.get("youden", {}),
            "spec_target": threshold_bundle.get("spec_target", {}),
        }
        if "dca" in threshold_bundle:
            metrics_at_thresholds["dca"] = threshold_bundle["dca"]
    if not _HAS_PLOTTING:
        return

    y = np.asarray(y_true).astype(int)
    p = np.asarray(y_pred).astype(float)
    mask = np.isfinite(p) & np.isfinite(y)
    y = y[mask]
    p = p[mask]

    if len(y) == 0:
        return

    fig, ax = plt.subplots(figsize=(6.5, 6))
    ax.plot([0, 1], [0, 1], "k--", linewidth=1, alpha=0.6)

    if split_ids is not None:
        split_ids = np.asarray(split_ids)[mask]
        unique_splits = pd.Series(split_ids).dropna().unique().tolist()
    else:
        unique_splits = []

    if len(unique_splits) > 1:
        base_fpr = np.linspace(0, 1, 120)
        tprs = []
        aucs = []
        for sid in unique_splits:
            m = split_ids == sid
            y_s = y[m]
            p_s = p[m]
            if len(np.unique(y_s)) < 2:
                continue
            fpr, tpr, _ = roc_curve(y_s, p_s)
            tpr_i = np.interp(base_fpr, fpr, tpr)
            tpr_i[0] = 0.0
            tprs.append(tpr_i)
            aucs.append(roc_auc_score(y_s, p_s))

        if tprs:
            tprs = np.vstack(tprs)
            tpr_mean = np.mean(tprs, axis=0)
            tpr_sd = np.std(tprs, axis=0)
            tpr_lo = np.nanpercentile(tprs, 2.5, axis=0)
            tpr_hi = np.nanpercentile(tprs, 97.5, axis=0)
            auc_mean = float(np.mean(aucs))
            auc_sd = float(np.std(aucs))

            if not skip_ci_band:
                ax.fill_between(
                    base_fpr, tpr_lo, tpr_hi, color="steelblue", alpha=0.15, label="95% CI"
                )
            ax.fill_between(
                base_fpr,
                np.maximum(0, tpr_mean - tpr_sd),
                np.minimum(1, tpr_mean + tpr_sd),
                color="steelblue",
                alpha=0.30,
                label="±1 SD",
            )
            ax.plot(
                base_fpr,
                tpr_mean,
                color="steelblue",
                linewidth=2,
                label=f"AUC = {auc_mean:.3f} ± {auc_sd:.3f}",
            )
        else:
            fpr, tpr, _ = roc_curve(y, p)
            auc = roc_auc_score(y, p)
            ax.plot(fpr, tpr, color="steelblue", linewidth=2, label=f"AUC = {auc:.3f}")
    else:
        fpr, tpr, _ = roc_curve(y, p)
        auc = roc_auc_score(y, p)
        ax.plot(fpr, tpr, color="steelblue", linewidth=2, label=f"AUC = {auc:.3f}")

    if metrics_at_thresholds is not None:
        # Collect marker coordinates for overlap detection
        fpr_youden = None
        tpr_youden = None
        fpr_alpha = None
        tpr_alpha = None

        # Extract Youden coordinates
        if youden_threshold is not None and "youden" in metrics_at_thresholds:
            m = metrics_at_thresholds["youden"]
            fpr_youden = m.get("fpr", None)
            tpr_youden = m.get("tpr", None)

        # Extract spec_target coordinates
        spec_key = next(
            (k for k in ["alpha", "spec95", "spec_target"] if k in metrics_at_thresholds),
            None,
        )
        if alpha_threshold is not None and spec_key:
            m = metrics_at_thresholds[spec_key]
            fpr_alpha = m.get("fpr", None)
            tpr_alpha = m.get("tpr", None)

        # Check for overlap (within 2% of plot range)
        markers_overlap = False
        if (
            fpr_youden is not None
            and tpr_youden is not None
            and fpr_alpha is not None
            and tpr_alpha is not None
        ):
            dist = np.sqrt((fpr_youden - fpr_alpha) ** 2 + (tpr_youden - tpr_alpha) ** 2)
            markers_overlap = dist < 0.02  # 2% threshold for overlap

        # Apply offset if overlapping (shift Youden left, spec_target right)
        offset = 0.015 if markers_overlap else 0.0

        # Plot Youden marker
        if (
            fpr_youden is not None
            and tpr_youden is not None
            and 0 <= fpr_youden <= 1
            and 0 <= tpr_youden <= 1
        ):
            ax.scatter(
                [fpr_youden - offset],
                [tpr_youden],
                s=100,
                color="green",
                marker="o",
                edgecolors="darkgreen",
                linewidths=2,
                label="Youden",
                zorder=5,
            )

        # Plot spec_target marker
        if (
            fpr_alpha is not None
            and tpr_alpha is not None
            and 0 <= fpr_alpha <= 1
            and 0 <= tpr_alpha <= 1
        ):
            ax.scatter(
                [fpr_alpha + offset],
                [tpr_alpha],
                s=100,
                color="orange",
                marker="D",
                edgecolors="darkorange",
                linewidths=2,
                label="Alpha threshold",
                zorder=5,
            )

    ax.set_xlabel("False Positive Rate")
    ax.set_ylabel("True Positive Rate")
    ax.set_xlim([-0.02, 1.02])
    ax.set_ylim([-0.02, 1.02])
    if subtitle:
        ax.set_title(f"{title}\n{subtitle}", fontsize=12)
    else:
        ax.set_title(title, fontsize=12)
    ax.legend(loc="lower right", fontsize=9)
    ax.grid(True, alpha=0.2)

    bottom_margin = apply_plot_metadata(fig, meta_lines)
    plt.subplots_adjust(left=0.15, right=0.9, top=0.8, bottom=bottom_margin)
    plt.savefig(out_path, dpi=150, pad_inches=0.1)
    plt.close()


def plot_pr_curve(
    y_true: np.ndarray,
    y_pred: np.ndarray,
    out_path: Path,
    title: str,
    subtitle: str = "",
    split_ids: np.ndarray | None = None,
    meta_lines: Sequence[str] | None = None,
    skip_ci_band: bool = False,
) -> None:
    """
    Plot Precision-Recall curve with optional split-wise confidence bands.

    Args:
        y_true: True binary labels
        y_pred: Predicted probabilities
        out_path: Output file path
        title: Plot title
        subtitle: Optional subtitle
        split_ids: Array indicating split membership for each sample
        meta_lines: Optional metadata lines to display at bottom
        skip_ci_band: If True, skip rendering 95% CI band (only show ±1 SD).
            Useful for ensemble models where CI and SD are redundant.

    Returns:
        None. Saves plot to out_path.
    """
    if not _HAS_PLOTTING:
        return

    y = np.asarray(y_true).astype(int)
    p = np.asarray(y_pred).astype(float)
    mask = np.isfinite(p) & np.isfinite(y)
    y = y[mask]
    p = p[mask]

    if len(y) == 0:
        return

    baseline = np.mean(y)
    fig, ax = plt.subplots(figsize=(6.5, 6))
    ax.axhline(
        y=baseline,
        color="k",
        linestyle="--",
        linewidth=1,
        alpha=0.6,
        label=f"Prevalence = {baseline:.4f}",
    )

    if split_ids is not None:
        split_ids = np.asarray(split_ids)[mask]
        unique_splits = pd.Series(split_ids).dropna().unique().tolist()
    else:
        unique_splits = []

    if len(unique_splits) > 1:
        base_recall = np.linspace(0, 1, 120)
        precisions = []
        aps = []
        for sid in unique_splits:
            m = split_ids == sid
            y_s = y[m]
            p_s = p[m]
            if len(np.unique(y_s)) < 2:
                continue
            precision, recall, _ = precision_recall_curve(y_s, p_s)
            precision_i = np.interp(base_recall, recall[::-1], precision[::-1])
            precisions.append(precision_i)
            aps.append(average_precision_score(y_s, p_s))

        if precisions:
            precisions = np.vstack(precisions)
            prec_mean = np.mean(precisions, axis=0)
            prec_sd = np.std(precisions, axis=0)
            prec_lo = np.nanpercentile(precisions, 2.5, axis=0)
            prec_hi = np.nanpercentile(precisions, 97.5, axis=0)
            ap_mean = float(np.mean(aps))
            ap_sd = float(np.std(aps))

            if not skip_ci_band:
                ax.fill_between(
                    base_recall,
                    np.clip(prec_lo, 0, 1),
                    np.clip(prec_hi, 0, 1),
                    color="steelblue",
                    alpha=0.15,
                    label="95% CI",
                )
            ax.fill_between(
                base_recall,
                np.clip(prec_mean - prec_sd, 0, 1),
                np.clip(prec_mean + prec_sd, 0, 1),
                color="steelblue",
                alpha=0.30,
                label="±1 SD",
            )
            ax.plot(
                base_recall,
                prec_mean,
                color="steelblue",
                linewidth=2,
                label=f"AP = {ap_mean:.3f} ± {ap_sd:.3f}",
            )
        else:
            precision, recall, _ = precision_recall_curve(y, p)
            ap = average_precision_score(y, p)
            ax.plot(
                recall,
                precision,
                color="steelblue",
                linewidth=2,
                label=f"AP = {ap:.3f}",
            )
    else:
        precision, recall, _ = precision_recall_curve(y, p)
        ap = average_precision_score(y, p)
        ax.plot(recall, precision, color="steelblue", linewidth=2, label=f"AP = {ap:.3f}")

    ax.set_xlabel("Recall (Sensitivity)")
    ax.set_ylabel("Precision (PPV)")
    ax.set_xlim([-0.02, 1.02])
    ax.set_ylim([-0.02, 1.02])
    if subtitle:
        ax.set_title(f"{title}\n{subtitle}", fontsize=12)
    else:
        ax.set_title(title, fontsize=12)
    ax.legend(loc="upper right", fontsize=9)
    ax.grid(True, alpha=0.2)

    bottom_margin = apply_plot_metadata(fig, meta_lines)
    plt.subplots_adjust(left=0.15, right=0.9, top=0.8, bottom=bottom_margin)
    plt.savefig(out_path, dpi=150, pad_inches=0.1)
    plt.close()
